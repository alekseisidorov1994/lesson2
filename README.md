# Разбор второй лекции
### Ссылочная природа объектов
***
В JS выделяют два типа данных: объекты и примитивы. При копировании примитива скопируется сам примитив. При копировании объека,
скопируется не сам объект, а ссыкла на него. Объект всегда в едиственном числе, а ссылок на него может быть сколько угодно. Новый объект создается только в момент присовения значения или когда в методе/функции присутствует return. Объект состоит из методов и полей. Метод -
это функция с привязкой к контексту. Поля или свойства - это характеристики объекта на которые можно ссылатся.  
### Заимствование контекста
***
Как мы знаем метод QuerySelectorAll возвращает нам псевдомассив. Псевдомассив - это объект, структура которого совпадает со структурой массива (т.е. он хранит элементы в индексах от 0 до length-1), но при этом он не обладает методами, свойственными полноценным массивам из-за отличий в прототипе. Для того, чтобы использовать методы массива на псевдомассиве нужно преобразовать его в массив. Преобразовать в массив можно используя Array.from(QSA). Если нам нужно использовать методы массива без преобразования, то применяем заимстование контекста Array.prototype.filter.call(QSA, CallBack). Метод call('контекст','arg'). CallBack в роле аргумета call, так как метода filter() принимает в качества агрумента callback функцию. Мы берем свойство prototype из массива Array, в котором содержится метод filter и вызываем его в контексте QSA. Это и есть заимствование методов/контекста.
### Магия \_\_proto__
***
\_\_proto__ - это скрытое свойство объекта, которое ссылается на прототип. Свойство __proto__ срабатывает автоматически при поиске методов и свойств, которых нет у самого объекта и поиск продолжается у его прототипа.  
`const c={g:5} const obj ={a: 2,b: 3,__proto__: c}`  
При `obj.g` результат будет равен 5. Здесь `с` является прототип для `obj` и если какого-то свойста нет у объекта, поиск продожится по ссылке \_\_proto__ у его прототипа. Если из прототипа мы хотит использовать метод на нашем объекте, то вызов метода будет в контесте нашего объекта, а не в контесте прототипа. Это значит, что при вызове метода прототипа, this будет ссылатся на объект для которого был сделал вызов, а не там где объявлен метод. Это похоже на заимстование контекста Array.prototype.filter.call(QSA, CallBack).У объекта может быть только один прототип, тогда как у прототипа может быть множество дочерних элементов.  
### Классы
***
Класс - удобная констукция для задания функции констуктора и прототипа. На рисунке ниже показано как выглядит класс, если его не записывать 
в по ES5 или ES6.
![Так выглядить класс](/class.png)  
  
До ES6 так каковых классов не было. Использовалась функция конструктор и свойство prototype.  
![Так выглядить класс](/class1.png)  
Person- функция коструктор. У нее есть свойство prototype, в которое по умолчанию записан сам коструктор. В это свойство мы добавляем методы. И так как person является ребенком Person, он может использовать свойства родителя.  
Классы в ES6 выглядят вот так:  
![Так выглядить класс](/class2.png)  

Класс могу наследовать друг от друга при помощи ключевого слова `extends`.  `class Cat extends Animal{}`. В данный момент класс `Cat` и `Animal` идентичны до тех пор пока мы не напишем что-то в `Cat`. Если мы в Cat будем использовать конструктор, то прежде чем инициализировать переменные, необходимо сначала вызвать коструктор родителя для этого используется  `super()` и передать в него необходимые переменные. В JS  класса мы вызываем суперконструктор, так как конструктор родителя нельзя переопределить, его можно только расширить или унаследовать. `super` работает и для методов, это нужно для того, если у ребенка и родителя одиннаковые методы, но мы хотит, чтоты сначала сработал метод родителя:  method(){`super.method()`..описание метода...}

### Get & Set
***
Это функции, которые используется для присвоения и получения значений. Если метод никамим образом не изменяет состояние объекта рекомендуется использовать set и get. Также set и get можно использовать, чтобы скрыть доступ до каких-то переменных и методов.
Get вызывается когда мы хоть узнать значение, Set когда хотит изменить значение.  
### Статические методы и свойста
***
Это методы/свойства, которые принадлежат самому классу. Это значит, что использовать может их сам класс, а не его экземпляры. Это достигается при помощи модификатора static. Перед методом или свойтвом вставляем static и доступут до них только у класса.  
### Цепной стиль
***
Цепной стиль обеспечивается с помощью `retrun: this`, если в классе каждый в конце каждого метода будет `retrun: this`, то мы сможем по цепочке использовать методы. А если добавить и статический метод create(), то можно вообще обойтись без переменных.  
![Так выглядить класс](/class3.png)  



